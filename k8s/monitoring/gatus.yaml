apiVersion: v1
items:
- apiVersion: v1
  kind: Pod
  metadata:
    annotations:
      kubectl.kubernetes.io/restartedAt: "2025-10-06T08:15:50+01:00"
    generateName: gatus-5c5564b497-
    labels:
      app: gatus
      pod-template-hash: 5c5564b497
    name: gatus-5c5564b497-7pspx
    namespace: status
    ownerReferences:
    - apiVersion: apps/v1
      blockOwnerDeletion: true
      controller: true
      kind: ReplicaSet
      name: gatus-5c5564b497
  spec:
    containers:
    - image: twinproduction/gatus:v5.8.0
      imagePullPolicy: IfNotPresent
      livenessProbe:
        failureThreshold: 3
        httpGet:
          path: /health
          port: 8080
          scheme: HTTP
        initialDelaySeconds: 10
        periodSeconds: 30
        successThreshold: 1
        timeoutSeconds: 1
      name: gatus
      ports:
      - containerPort: 8080
        name: http
        protocol: TCP
      readinessProbe:
        failureThreshold: 3
        httpGet:
          path: /health
          port: 8080
          scheme: HTTP
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      resources:
        limits:
          cpu: 500m
          memory: 512Mi
        requests:
          cpu: 100m
          memory: 128Mi
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      volumeMounts:
      - mountPath: /config
        name: config
      - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
        name: kube-api-access-l7lpb
        readOnly: true
    dnsPolicy: ClusterFirst
    enableServiceLinks: true
    nodeName: ubuntu-16gb-hel1-1
    preemptionPolicy: PreemptLowerPriority
    priority: 0
    restartPolicy: Always
    schedulerName: default-scheduler
    securityContext: {}
    serviceAccount: default
    serviceAccountName: default
    terminationGracePeriodSeconds: 30
    tolerations:
    - effect: NoExecute
      key: node.kubernetes.io/not-ready
      operator: Exists
      tolerationSeconds: 300
    - effect: NoExecute
      key: node.kubernetes.io/unreachable
      operator: Exists
      tolerationSeconds: 300
    volumes:
    - configMap:
        defaultMode: 420
        name: gatus-config
      name: config
    - name: kube-api-access-l7lpb
      projected:
        defaultMode: 420
        sources:
        - serviceAccountToken:
            expirationSeconds: 3607
            path: token
        - configMap:
            items:
            - key: ca.crt
              path: ca.crt
            name: kube-root-ca.crt
        - downwardAPI:
            items:
            - fieldRef:
                apiVersion: v1
                fieldPath: metadata.namespace
              path: namespace
  status:
    conditions:
    - lastProbeTime: null
      lastTransitionTime: "2025-10-06T07:15:51Z"
      status: "True"
      type: PodReadyToStartContainers
    - lastProbeTime: null
      lastTransitionTime: "2025-10-06T07:15:50Z"
      status: "True"
      type: Initialized
    - lastProbeTime: null
      lastTransitionTime: "2025-10-06T07:16:02Z"
      status: "True"
      type: Ready
    - lastProbeTime: null
      lastTransitionTime: "2025-10-06T07:16:02Z"
      status: "True"
      type: ContainersReady
    - lastProbeTime: null
      lastTransitionTime: "2025-10-06T07:15:50Z"
      status: "True"
      type: PodScheduled
    containerStatuses:
    - allocatedResources:
        cpu: 100m
        memory: 128Mi
      containerID: containerd://7694085ea9eae1d64d9039c8bcce1900f06d32516d8bca9eae4c3c9ccf074a68
      image: docker.io/twinproduction/gatus:v5.8.0
      imageID: docker.io/twinproduction/gatus@sha256:17a08e7500a6469025a2f4e08dd7502956589ae0231f34933f4badc053e6626c
      lastState: {}
      name: gatus
      ready: true
      resources:
        limits:
          cpu: 500m
          memory: 512Mi
        requests:
          cpu: 100m
          memory: 128Mi
      restartCount: 0
      started: true
      state:
        running:
          startedAt: "2025-10-06T07:15:50Z"
      user:
        linux:
          gid: 0
          supplementalGroups:
          - 0
      volumeMounts:
      - mountPath: /config
        name: config
      - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
        name: kube-api-access-l7lpb
        readOnly: true
        recursiveReadOnly: Disabled
    hostIP: 46.62.223.198
    hostIPs:
    - ip: 46.62.223.198
    - ip: 2a01:4f9:c013:abef::1
    phase: Running
    podIP: 10.42.0.237
    podIPs:
    - ip: 10.42.0.237
    qosClass: Burstable
    startTime: "2025-10-06T07:15:50Z"
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"labels":{"app":"gatus"},"name":"gatus","namespace":"status"},"spec":{"ports":[{"name":"http","port":80,"targetPort":8080}],"selector":{"app":"gatus"},"type":"ClusterIP"}}
    labels:
      app: gatus
    name: gatus
    namespace: status
  spec:
    clusterIP: 10.43.93.9
    clusterIPs:
    - 10.43.93.9
    internalTrafficPolicy: Cluster
    ipFamilies:
    - IPv4
    ipFamilyPolicy: SingleStack
    ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: 8080
    selector:
      app: gatus
    sessionAffinity: None
    type: ClusterIP
  status:
    loadBalancer: {}
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"name":"status-page","namespace":"status"},"spec":{"ports":[{"name":"http","port":80,"targetPort":3000}],"selector":{"app":"status-page"},"type":"ClusterIP"}}
    name: status-page
    namespace: status
  spec:
    clusterIP: 10.43.163.104
    clusterIPs:
    - 10.43.163.104
    internalTrafficPolicy: Cluster
    ipFamilies:
    - IPv4
    ipFamilyPolicy: SingleStack
    ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: 3000
    selector:
      app: status-page
    sessionAffinity: None
    type: ClusterIP
  status:
    loadBalancer: {}
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"name":"uptime-kuma","namespace":"status"},"spec":{"ports":[{"port":3001,"targetPort":3001}],"selector":{"app":"uptime-kuma"}}}
    name: uptime-kuma
    namespace: status
  spec:
    clusterIP: 10.43.234.78
    clusterIPs:
    - 10.43.234.78
    internalTrafficPolicy: Cluster
    ipFamilies:
    - IPv4
    ipFamilyPolicy: SingleStack
    ports:
    - port: 3001
      protocol: TCP
      targetPort: 3001
    selector:
      app: uptime-kuma
    sessionAffinity: None
    type: ClusterIP
  status:
    loadBalancer: {}
- apiVersion: apps/v1
  kind: Deployment
  metadata:
    annotations:
      deployment.kubernetes.io/revision: "3"
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"apps/v1","kind":"Deployment","metadata":{"annotations":{},"labels":{"app":"gatus"},"name":"gatus","namespace":"status"},"spec":{"replicas":1,"selector":{"matchLabels":{"app":"gatus"}},"template":{"metadata":{"labels":{"app":"gatus"}},"spec":{"containers":[{"image":"twinproduction/gatus:v5.8.0","livenessProbe":{"httpGet":{"path":"/health","port":8080},"initialDelaySeconds":10,"periodSeconds":30},"name":"gatus","ports":[{"containerPort":8080,"name":"http"}],"readinessProbe":{"httpGet":{"path":"/health","port":8080},"initialDelaySeconds":5,"periodSeconds":10},"resources":{"limits":{"cpu":"500m","memory":"512Mi"},"requests":{"cpu":"100m","memory":"128Mi"}},"volumeMounts":[{"mountPath":"/config","name":"config"}]}],"volumes":[{"configMap":{"name":"gatus-config"},"name":"config"}]}}}}
    labels:
      app: gatus
    name: gatus
    namespace: status
  spec:
    progressDeadlineSeconds: 600
    replicas: 1
    revisionHistoryLimit: 10
    selector:
      matchLabels:
        app: gatus
    strategy:
      rollingUpdate:
        maxSurge: 25%
        maxUnavailable: 25%
      type: RollingUpdate
    template:
      metadata:
        annotations:
          kubectl.kubernetes.io/restartedAt: "2025-10-06T08:15:50+01:00"
        labels:
          app: gatus
      spec:
        containers:
        - image: twinproduction/gatus:v5.8.0
          imagePullPolicy: IfNotPresent
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 1
          name: gatus
          ports:
          - containerPort: 8080
            name: http
            protocol: TCP
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
          - mountPath: /config
            name: config
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
        volumes:
        - configMap:
            defaultMode: 420
            name: gatus-config
          name: config
  status:
    availableReplicas: 1
    conditions:
    - lastTransitionTime: "2025-10-06T07:08:43Z"
      lastUpdateTime: "2025-10-06T07:08:43Z"
      message: Deployment has minimum availability.
      reason: MinimumReplicasAvailable
      status: "True"
      type: Available
    - lastTransitionTime: "2025-10-06T07:08:27Z"
      lastUpdateTime: "2025-10-06T07:16:02Z"
      message: ReplicaSet "gatus-5c5564b497" has successfully progressed.
      reason: NewReplicaSetAvailable
      status: "True"
      type: Progressing
    observedGeneration: 3
    readyReplicas: 1
    replicas: 1
    updatedReplicas: 1
- apiVersion: apps/v1
  kind: ReplicaSet
  metadata:
    annotations:
      deployment.kubernetes.io/desired-replicas: "1"
      deployment.kubernetes.io/max-replicas: "2"
      deployment.kubernetes.io/revision: "1"
    labels:
      app: gatus
      pod-template-hash: 58c9d65659
    name: gatus-58c9d65659
    namespace: status
    ownerReferences:
    - apiVersion: apps/v1
      blockOwnerDeletion: true
      controller: true
      kind: Deployment
      name: gatus
  spec:
    replicas: 0
    selector:
      matchLabels:
        app: gatus
        pod-template-hash: 58c9d65659
    template:
      metadata:
        labels:
          app: gatus
          pod-template-hash: 58c9d65659
      spec:
        containers:
        - image: twinproduction/gatus:v5.8.0
          imagePullPolicy: IfNotPresent
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 1
          name: gatus
          ports:
          - containerPort: 8080
            name: http
            protocol: TCP
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
          - mountPath: /config
            name: config
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
        volumes:
        - configMap:
            defaultMode: 420
            name: gatus-config
          name: config
  status:
    observedGeneration: 2
    replicas: 0
- apiVersion: apps/v1
  kind: ReplicaSet
  metadata:
    annotations:
      deployment.kubernetes.io/desired-replicas: "1"
      deployment.kubernetes.io/max-replicas: "2"
      deployment.kubernetes.io/revision: "3"
    labels:
      app: gatus
      pod-template-hash: 5c5564b497
    name: gatus-5c5564b497
    namespace: status
    ownerReferences:
    - apiVersion: apps/v1
      blockOwnerDeletion: true
      controller: true
      kind: Deployment
      name: gatus
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: gatus
        pod-template-hash: 5c5564b497
    template:
      metadata:
        annotations:
          kubectl.kubernetes.io/restartedAt: "2025-10-06T08:15:50+01:00"
        labels:
          app: gatus
          pod-template-hash: 5c5564b497
      spec:
        containers:
        - image: twinproduction/gatus:v5.8.0
          imagePullPolicy: IfNotPresent
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 1
          name: gatus
          ports:
          - containerPort: 8080
            name: http
            protocol: TCP
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
          - mountPath: /config
            name: config
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
        volumes:
        - configMap:
            defaultMode: 420
            name: gatus-config
          name: config
  status:
    availableReplicas: 1
    fullyLabeledReplicas: 1
    observedGeneration: 1
    readyReplicas: 1
    replicas: 1
- apiVersion: apps/v1
  kind: ReplicaSet
  metadata:
    annotations:
      deployment.kubernetes.io/desired-replicas: "1"
      deployment.kubernetes.io/max-replicas: "2"
      deployment.kubernetes.io/revision: "2"
    labels:
      app: gatus
      pod-template-hash: "897667965"
    name: gatus-897667965
    namespace: status
    ownerReferences:
    - apiVersion: apps/v1
      blockOwnerDeletion: true
      controller: true
      kind: Deployment
      name: gatus
  spec:
    replicas: 0
    selector:
      matchLabels:
        app: gatus
        pod-template-hash: "897667965"
    template:
      metadata:
        annotations:
          kubectl.kubernetes.io/restartedAt: "2025-10-06T08:11:50+01:00"
        labels:
          app: gatus
          pod-template-hash: "897667965"
      spec:
        containers:
        - image: twinproduction/gatus:v5.8.0
          imagePullPolicy: IfNotPresent
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 1
          name: gatus
          ports:
          - containerPort: 8080
            name: http
            protocol: TCP
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /health
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
          - mountPath: /config
            name: config
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        terminationGracePeriodSeconds: 30
        volumes:
        - configMap:
            defaultMode: 420
            name: gatus-config
          name: config
  status:
    observedGeneration: 2
    replicas: 0
- apiVersion: v1
  data:
    config.yaml: |
      metrics: true
      storage:
        type: postgres
        path: "postgres://gatus_user:GATUS_DB_PASSWORD_PLACEHOLDER@postgresql-0.postgresql.infrastructure.svc.cluster.local:5432/gatus?sslmode=disable"

      endpoints:
        - name: Core Pipeline (Production)
          group: Applications
          url: "https://core-pipeline.theedgestory.org/health"
          interval: 60s
          conditions:
            - "[STATUS] == 200"
            - "[RESPONSE_TIME] < 1000"
          alerts:
            - type: discord
              enabled: false

        - name: Core Pipeline (Development)
          group: Applications
          url: "https://core-pipeline-dev.theedgestory.org/health"
          interval: 60s
          conditions:
            - "[STATUS] == 200"
            - "[RESPONSE_TIME] < 1000"

        - name: PostgreSQL
          group: Infrastructure
          url: "tcp://postgresql-0.postgresql.infrastructure.svc.cluster.local:5432"
          interval: 60s
          conditions:
            - "[CONNECTED] == true"

        - name: Redis
          group: Infrastructure
          url: "tcp://redis-0.redis.infrastructure.svc.cluster.local:6379"
          interval: 60s
          conditions:
            - "[CONNECTED] == true"

        - name: Kafka
          group: Infrastructure
          url: "tcp://kafka-cluster-kafka-bootstrap.infrastructure.svc.cluster.local:9092"
          interval: 60s
          conditions:
            - "[CONNECTED] == true"

        - name: Prometheus
          group: Infrastructure
          url: "http://prometheus.monitoring.svc.cluster.local:9090/-/healthy"
          interval: 60s
          conditions:
            - "[STATUS] == 200"

        - name: Hetzner Cloud
          group: External
          url: "https://status.hetzner.com"
          interval: 300s
          conditions:
            - "[STATUS] == 200"
            - "[RESPONSE_TIME] < 3000"

        - name: GitHub API
          group: External
          url: "https://api.github.com/status"
          interval: 300s
          conditions:
            - "[STATUS] == 200"

      ui:
        title: "The Edge Story - System Status"
        header: "The Edge Story"
        description: "Real-time status and uptime monitoring powered by Gatus"
        logo: ""
        link: ""
  kind: ConfigMap
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"v1","data":{"config.yaml":"metrics: true\nstorage:\n  type: postgres\n  path: \"postgres://gatus_user:GATUS_DB_PASSWORD_PLACEHOLDER@postgresql-0.postgresql.infrastructure.svc.cluster.local:5432/gatus?sslmode=disable\"\n\nendpoints:\n  - name: Core Pipeline (Production)\n    group: Applications\n    url: \"https://core-pipeline.theedgestory.org/health\"\n    interval: 60s\n    conditions:\n      - \"[STATUS] == 200\"\n      - \"[RESPONSE_TIME] \u003c 1000\"\n    alerts:\n      - type: discord\n        enabled: false\n\n  - name: Core Pipeline (Development)\n    group: Applications\n    url: \"https://core-pipeline-dev.theedgestory.org/health\"\n    interval: 60s\n    conditions:\n      - \"[STATUS] == 200\"\n      - \"[RESPONSE_TIME] \u003c 1000\"\n\n  - name: PostgreSQL\n    group: Infrastructure\n    url: \"tcp://postgresql-0.postgresql.infrastructure.svc.cluster.local:5432\"\n    interval: 60s\n    conditions:\n      - \"[CONNECTED] == true\"\n\n  - name: Redis\n    group: Infrastructure\n    url: \"tcp://redis-0.redis.infrastructure.svc.cluster.local:6379\"\n    interval: 60s\n    conditions:\n      - \"[CONNECTED] == true\"\n\n  - name: Kafka\n    group: Infrastructure\n    url: \"tcp://kafka-cluster-kafka-bootstrap.infrastructure.svc.cluster.local:9092\"\n    interval: 60s\n    conditions:\n      - \"[CONNECTED] == true\"\n\n  - name: Prometheus\n    group: Infrastructure\n    url: \"http://prometheus.monitoring.svc.cluster.local:9090/-/healthy\"\n    interval: 60s\n    conditions:\n      - \"[STATUS] == 200\"\n\n  - name: Hetzner Cloud\n    group: External\n    url: \"https://status.hetzner.com\"\n    interval: 300s\n    conditions:\n      - \"[STATUS] == 200\"\n      - \"[RESPONSE_TIME] \u003c 3000\"\n\n  - name: GitHub API\n    group: External\n    url: \"https://api.github.com/status\"\n    interval: 300s\n    conditions:\n      - \"[STATUS] == 200\"\n\nui:\n  title: \"The Edge Story - System Status\"\n  header: \"The Edge Story\"\n  description: \"Real-time status and uptime monitoring powered by Gatus\"\n  logo: \"\"\n  link: \"\"\n"},"kind":"ConfigMap","metadata":{"annotations":{},"name":"gatus-config","namespace":"status"}}
    name: gatus-config
    namespace: status
- apiVersion: v1
  data:
    ca.crt: |
      -----BEGIN CERTIFICATE-----
      MIIBdzCCAR2gAwIBAgIBADAKBggqhkjOPQQDAjAjMSEwHwYDVQQDDBhrM3Mtc2Vy
      dmVyLWNhQDE3NTk3MTE0NTkwHhcNMjUxMDA2MDA0NDE5WhcNMzUxMDA0MDA0NDE5
      WjAjMSEwHwYDVQQDDBhrM3Mtc2VydmVyLWNhQDE3NTk3MTE0NTkwWTATBgcqhkjO
      PQIBBggqhkjOPQMBBwNCAARqGCXrxGpCMBkpMFvc0L21JXhiw3vTnT+gHqVRkI37
      9yo8rZpCpmRxhpdn0DzIu3w2jDUBqRRUhd9BMc2zu8wDo0IwQDAOBgNVHQ8BAf8E
      BAMCAqQwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUeZJG2OGuD6C3OiA9qA17
      dHxqCPUwCgYIKoZIzj0EAwIDSAAwRQIhAPnZhOfemvbu3wUUCI39bFiqaPoHp+jS
      mbHSD/JWBs3qAiAoPvUgbQvHvHEr0IrqNFFJvNOFecO+OwFznWbGebi9Qw==
      -----END CERTIFICATE-----
  kind: ConfigMap
  metadata:
    annotations:
      kubernetes.io/description: Contains a CA bundle that can be used to verify the
        kube-apiserver when using internal endpoints such as the internal service
        IP or kubernetes.default.svc. No other usage is guaranteed across distributions
        of Kubernetes clusters.
    name: kube-root-ca.crt
    namespace: status
- apiVersion: v1
  data:
    index.html: |
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>The Edge Story Status</title>
          <style>
              * {
                  margin: 0;
                  padding: 0;
                  box-sizing: border-box;
              }

              body {
                  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                  background: #f6f8fa;
                  color: #24292f;
                  line-height: 1.5;
              }

              .container {
                  max-width: 1012px;
                  margin: 0 auto;
                  padding: 40px 20px;
              }

              .header {
                  text-align: center;
                  margin-bottom: 48px;
              }

              .header h1 {
                  font-size: 32px;
                  font-weight: 600;
                  margin-bottom: 8px;
                  color: #24292f;
              }

              .header .tagline {
                  color: #57606a;
                  font-size: 16px;
              }

              .status-banner {
                  background: #fff;
                  border: 1px solid #d0d7de;
                  border-radius: 6px;
                  padding: 32px;
                  margin-bottom: 24px;
                  text-align: center;
              }

              .status-banner.operational {
                  border-left: 4px solid #1a7f37;
              }

              .status-banner.degraded {
                  border-left: 4px solid #bf8700;
              }

              .status-banner.down {
                  border-left: 4px solid #cf222e;
              }

              .status-icon {
                  font-size: 48px;
                  margin-bottom: 16px;
              }

              .status-title {
                  font-size: 24px;
                  font-weight: 600;
                  margin-bottom: 8px;
              }

              .status-banner.operational .status-title {
                  color: #1a7f37;
              }

              .status-banner.degraded .status-title {
                  color: #bf8700;
              }

              .status-banner.down .status-title {
                  color: #cf222e;
              }

              .status-description {
                  color: #57606a;
                  font-size: 14px;
              }

              .services {
                  background: #fff;
                  border: 1px solid #d0d7de;
                  border-radius: 6px;
                  margin-bottom: 24px;
              }

              .service-group {
                  padding: 24px;
                  border-bottom: 1px solid #d0d7de;
              }

              .service-group:last-child {
                  border-bottom: none;
              }

              .service-group-title {
                  font-size: 14px;
                  font-weight: 600;
                  color: #57606a;
                  text-transform: uppercase;
                  letter-spacing: 0.5px;
                  margin-bottom: 20px;
              }

              .service {
                  margin-bottom: 32px;
              }

              .service:last-child {
                  margin-bottom: 0;
              }

              .service-header {
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                  margin-bottom: 12px;
              }

              .service-name {
                  font-size: 16px;
                  font-weight: 500;
                  display: flex;
                  align-items: center;
                  gap: 8px;
              }

              .service-status {
                  display: flex;
                  align-items: center;
                  gap: 8px;
                  font-size: 14px;
              }

              .status-dot {
                  width: 10px;
                  height: 10px;
                  border-radius: 50%;
              }

              .status-dot.up {
                  background: #1a7f37;
              }

              .status-dot.down {
                  background: #cf222e;
              }

              .status-dot.checking {
                  background: #6e7781;
                  animation: pulse 1.5s infinite;
              }

              @keyframes pulse {
                  0%, 100% { opacity: 1; }
                  50% { opacity: 0.5; }
              }

              .uptime-container {
                  display: flex;
                  align-items: center;
                  gap: 16px;
              }

              .uptime-bars {
                  display: flex;
                  gap: 3px;
                  flex: 1;
              }

              .uptime-bar {
                  height: 34px;
                  flex: 1;
                  border-radius: 2px;
                  position: relative;
                  cursor: pointer;
                  transition: transform 0.2s;
              }

              .uptime-bar:hover {
                  transform: scaleY(1.1);
              }

              .uptime-bar.up {
                  background: #1a7f37;
              }

              .uptime-bar.degraded {
                  background: #bf8700;
              }

              .uptime-bar.down {
                  background: #cf222e;
              }

              .uptime-bar.no-data {
                  background: #eaeef2;
              }

              .uptime-percentage {
                  font-size: 14px;
                  font-weight: 600;
                  color: #1a7f37;
                  min-width: 60px;
                  text-align: right;
              }

              .uptime-days {
                  font-size: 12px;
                  color: #57606a;
                  margin-top: 8px;
                  display: flex;
                  justify-content: space-between;
              }

              .footer {
                  text-align: center;
                  padding: 32px 0;
                  color: #57606a;
                  font-size: 14px;
              }

              .footer a {
                  color: #0969da;
                  text-decoration: none;
              }

              .footer a:hover {
                  text-decoration: underline;
              }

              .last-updated {
                  background: #fff;
                  border: 1px solid #d0d7de;
                  border-radius: 6px;
                  padding: 16px;
                  text-align: center;
                  font-size: 14px;
                  color: #57606a;
                  margin-bottom: 24px;
              }

              .refresh-btn {
                  background: #1a7f37;
                  color: white;
                  border: none;
                  padding: 8px 16px;
                  border-radius: 6px;
                  font-size: 14px;
                  font-weight: 500;
                  cursor: pointer;
                  margin-left: 12px;
                  transition: background 0.2s;
              }

              .refresh-btn:hover {
                  background: #1f883d;
              }

              .response-time {
                  font-size: 12px;
                  color: #57606a;
              }

              .incidents {
                  background: #fff;
                  border: 1px solid #d0d7de;
                  border-radius: 6px;
                  padding: 24px;
                  margin-bottom: 24px;
              }

              .incidents-title {
                  font-size: 18px;
                  font-weight: 600;
                  margin-bottom: 16px;
              }

              .incident {
                  padding: 16px 0;
                  border-bottom: 1px solid #d0d7de;
              }

              .incident:last-child {
                  border-bottom: none;
              }

              .incident-title {
                  font-size: 14px;
                  font-weight: 600;
                  margin-bottom: 4px;
              }

              .incident-time {
                  font-size: 12px;
                  color: #57606a;
              }

              .no-incidents {
                  text-align: center;
                  padding: 32px;
                  color: #57606a;
              }

              .no-incidents-icon {
                  font-size: 48px;
                  margin-bottom: 16px;
              }
          </style>
      </head>
      <body>
          <div class="container">
              <div class="header">
                  <h1>The Edge Story Status</h1>
                  <p class="tagline">Real-time status and uptime monitoring</p>
              </div>

              <div class="status-banner operational" id="overall-status">
                  <div class="status-icon" id="status-icon">✓</div>
                  <div class="status-title" id="status-title">All Systems Operational</div>
                  <div class="status-description" id="status-description">All services are running normally</div>
              </div>

              <div class="last-updated">
                  Last checked: <span id="last-updated">Never</span>
                  <button class="refresh-btn" onclick="checkAllServices()">↻ Refresh</button>
              </div>

              <div class="services">
                  <div class="service-group">
                      <div class="service-group-title">Applications</div>
                      <div id="applications"></div>
                  </div>

                  <div class="service-group">
                      <div class="service-group-title">Infrastructure</div>
                      <div id="infrastructure"></div>
                  </div>

                  <div class="service-group">
                      <div class="service-group-title">External Dependencies</div>
                      <div id="external"></div>
                  </div>
              </div>

              <div class="incidents">
                  <div class="incidents-title">Recent Incidents</div>
                  <div class="no-incidents">
                      <div class="no-incidents-icon">✨</div>
                      <div>No incidents in the last 90 days</div>
                  </div>
              </div>

              <div class="footer">
                  <p>Automated checks every 60 seconds · Powered by The Edge Story Infrastructure</p>
              </div>
          </div>

          <script>
              const services = {
                  applications: [
                      {
                          name: 'Core Pipeline (Production)',
                          description: 'Production API service',
                          url: '/api/check/core-pipeline-prod',
                          prometheusId: 'core-pipeline-prod',
                          type: 'prometheus'
                      },
                      {
                          name: 'Core Pipeline (Development)',
                          description: 'Development API service',
                          url: '/api/check/core-pipeline-dev',
                          prometheusId: 'core-pipeline-dev',
                          type: 'prometheus'
                      }
                  ],
                  infrastructure: [
                      {
                          name: 'PostgreSQL',
                          description: 'Shared database',
                          url: '/api/check/postgresql',
                          prometheusId: 'postgresql',
                          type: 'prometheus'
                      },
                      {
                          name: 'Redis',
                          description: 'Cache and queue system',
                          url: '/api/check/redis',
                          prometheusId: 'redis',
                          type: 'prometheus'
                      },
                      {
                          name: 'Kafka',
                          description: 'Message broker',
                          url: '/api/check/kafka',
                          prometheusId: 'kafka',
                          type: 'prometheus'
                      }
                  ],
                  external: [
                      {
                          name: 'Hetzner Server',
                          description: 'K3s cluster (46.62.223.198)',
                          url: '/api/check/hetzner',
                          type: 'prometheus'
                      },
                      {
                          name: 'GitHub',
                          description: 'Code repository',
                          url: 'https://api.github.com/status',
                          type: 'http'
                      }
                  ]
              };

              // Fetch uptime history from Prometheus
              async function fetchUptimeHistory(service) {
                  if (!service.prometheusId) {
                      // Fallback to local history for non-Prometheus services
                      return generateLocalUptimeHistory(service.name);
                  }

                  try {
                      const response = await fetch(`/api/uptime/${service.prometheusId}?days=90`);
                      if (!response.ok) {
                          return generateLocalUptimeHistory(service.name);
                      }

                      const data = await response.json();
                      if (data.history && data.history.length > 0) {
                          return data.history;
                      }

                      return generateLocalUptimeHistory(service.name);
                  } catch (error) {
                      console.error('Failed to fetch uptime history:', error);
                      return generateLocalUptimeHistory(service.name);
                  }
              }

              // Generate local uptime history (fallback)
              function generateLocalUptimeHistory(serviceName) {
                  const stored = localStorage.getItem(`uptime_${serviceName}`);
                  if (stored) {
                      return JSON.parse(stored);
                  }

                  // Initialize with 90 days of data
                  const history = [];
                  for (let i = 89; i >= 0; i--) {
                      const date = new Date();
                      date.setDate(date.getDate() - i);
                      history.push({
                          date: date.toISOString().split('T')[0],
                          status: 'up',
                          uptime: 100
                      });
                  }
                  return history;
              }

              function updateLocalUptimeHistory(serviceName, isUp) {
                  let history = generateLocalUptimeHistory(serviceName);
                  const today = new Date().toISOString().split('T')[0];

                  const todayIndex = history.findIndex(h => h.date === today);
                  if (todayIndex >= 0) {
                      if (!isUp) {
                          history[todayIndex].status = 'down';
                          history[todayIndex].uptime = 0;
                      }
                  } else {
                      // Add today's data
                      history.push({
                          date: today,
                          status: isUp ? 'up' : 'down',
                          uptime: isUp ? 100 : 0
                      });
                      // Keep only last 90 days
                      if (history.length > 90) {
                          history = history.slice(-90);
                      }
                  }

                  localStorage.setItem(`uptime_${serviceName}`, JSON.stringify(history));
                  return history;
              }

              function calculateUptime(history) {
                  const total = history.reduce((sum, day) => sum + day.uptime, 0);
                  return (total / history.length).toFixed(2);
              }

              function renderUptimeBars(history) {
                  return history.map(day => {
                      let statusClass = 'no-data';
                      if (day.uptime === 100) statusClass = 'up';
                      else if (day.uptime > 0) statusClass = 'degraded';
                      else if (day.uptime === 0) statusClass = 'down';

                      return `<div class="uptime-bar ${statusClass}" title="${day.date}: ${day.uptime}% uptime"></div>`;
                  }).join('');
              }

              async function renderService(service, status, containerId) {
                  const container = document.getElementById(containerId);

                  const statusClass = status ? status.status : 'checking';
                  const statusText = status ? (status.status === 'up' ? 'Operational' : 'Down') : 'Checking...';
                  const responseTime = status && status.responseTime ? `${status.responseTime}ms` : '';

                  // Fetch uptime history from Prometheus
                  const history = await fetchUptimeHistory(service);
                  const uptimePercentage = calculateUptime(history);

                  const serviceDiv = document.createElement('div');
                  serviceDiv.className = 'service';

                  serviceDiv.innerHTML = `
                      <div class="service-header">
                          <div class="service-name">
                              ${service.name}
                              ${responseTime ? `<span class="response-time">${responseTime}</span>` : ''}
                          </div>
                          <div class="service-status">
                              <span class="status-dot ${statusClass}"></span>
                              <span>${statusText}</span>
                          </div>
                      </div>
                      <div class="uptime-container">
                          <div class="uptime-bars">
                              ${renderUptimeBars(history)}
                          </div>
                          <div class="uptime-percentage">${uptimePercentage}%</div>
                      </div>
                      <div class="uptime-days">
                          <span>90 days ago</span>
                          <span>${uptimePercentage}% uptime</span>
                          <span>Today</span>
                      </div>
                  `;

                  container.appendChild(serviceDiv);
              }

              async function checkService(service) {
                  const startTime = Date.now();
                  try {
                      const response = await fetch(service.url, {
                          method: 'GET',
                          mode: service.type === 'http' ? 'cors' : 'same-origin',
                          signal: AbortSignal.timeout(5000)
                      });

                      const responseTime = Date.now() - startTime;
                      const isUp = response.ok;

                      return {
                          status: isUp ? 'up' : 'down',
                          responseTime: responseTime,
                          lastChecked: new Date()
                      };
                  } catch (error) {
                      return {
                          status: 'down',
                          responseTime: null,
                          lastChecked: new Date(),
                          error: error.message
                      };
                  }
              }

              async function checkAllServices() {
                  // Clear containers
                  document.getElementById('applications').innerHTML = '';
                  document.getElementById('infrastructure').innerHTML = '';
                  document.getElementById('external').innerHTML = '';

                  let totalServices = 0;
                  let upServices = 0;

                  // Check all services
                  for (const [category, serviceList] of Object.entries(services)) {
                      const promises = serviceList.map(async (service) => {
                          const status = await checkService(service);
                          totalServices++;
                          if (status.status === 'up') upServices++;
                          return { service, status };
                      });

                      const results = await Promise.all(promises);

                      // Render with results
                      for (const { service, status } of results) {
                          await renderService(service, status, category);
                      }
                  }

                  // Update overall status
                  const overallStatus = document.getElementById('overall-status');
                  const statusIcon = document.getElementById('status-icon');
                  const statusTitle = document.getElementById('status-title');
                  const statusDescription = document.getElementById('status-description');

                  overallStatus.className = 'status-banner';
                  if (upServices === totalServices) {
                      overallStatus.classList.add('operational');
                      statusIcon.textContent = '✓';
                      statusTitle.textContent = 'All Systems Operational';
                      statusDescription.textContent = 'All services are running normally';
                  } else if (upServices === 0) {
                      overallStatus.classList.add('down');
                      statusIcon.textContent = '×';
                      statusTitle.textContent = 'Major Outage';
                      statusDescription.textContent = 'All services are currently down';
                  } else {
                      overallStatus.classList.add('degraded');
                      statusIcon.textContent = '!';
                      statusTitle.textContent = 'Partial Outage';
                      statusDescription.textContent = `${upServices} of ${totalServices} services operational`;
                  }

                  document.getElementById('last-updated').textContent = new Date().toLocaleString();
              }

              // Initial check
              checkAllServices();

              // Auto-refresh every 60 seconds
              setInterval(checkAllServices, 60000);
          </script>
      </body>
      </html>
    package.json: |
      {
        "name": "status-page",
        "version": "1.0.0",
        "description": "The Edge Story System Status Page",
        "main": "server.js",
        "scripts": {
          "start": "node server.js"
        },
        "dependencies": {
          "express": "^4.18.2"
        },
        "engines": {
          "node": ">=18.0.0"
        }
      }
    server.js: |
      const express = require('express');
      const path = require('path');

      const app = express();
      const PORT = process.env.PORT || 3000;

      // Prometheus server URL
      const PROMETHEUS_URL = process.env.PROMETHEUS_URL || 'http://prometheus.monitoring.svc.cluster.local:9090';

      // Serve static HTML
      app.use(express.static(__dirname));

      // Helper function to query Prometheus
      async function queryPrometheus(query) {
          try {
              const url = `${PROMETHEUS_URL}/api/v1/query?query=${encodeURIComponent(query)}`;
              const response = await fetch(url);
              if (!response.ok) {
                  throw new Error(`Prometheus query failed: ${response.statusText}`);
              }
              const data = await response.json();
              return data;
          } catch (error) {
              console.error('Prometheus query error:', error.message);
              return null;
          }
      }

      // Helper function to query Prometheus range
      async function queryPrometheusRange(query, start, end, step = '1h') {
          try {
              const url = `${PROMETHEUS_URL}/api/v1/query_range?query=${encodeURIComponent(query)}&start=${start}&end=${end}&step=${step}`;
              const response = await fetch(url);
              if (!response.ok) {
                  throw new Error(`Prometheus range query failed: ${response.statusText}`);
              }
              const data = await response.json();
              return data;
          } catch (error) {
              console.error('Prometheus range query error:', error.message);
              return null;
          }
      }

      // API endpoint to check core-pipeline-prod
      app.get('/api/check/core-pipeline-prod', async (req, res) => {
          const result = await queryPrometheus('up{job="core-pipeline-prod"}');

          if (result && result.status === 'success' && result.data.result.length > 0) {
              const value = parseFloat(result.data.result[0].value[1]);
              res.json({
                  status: value === 1 ? 'up' : 'down',
                  responseTime: null
              });
          } else {
              res.json({ status: 'down', responseTime: null });
          }
      });

      // API endpoint to check core-pipeline-dev
      app.get('/api/check/core-pipeline-dev', async (req, res) => {
          const result = await queryPrometheus('up{job="core-pipeline-dev"}');

          if (result && result.status === 'success' && result.data.result.length > 0) {
              const value = parseFloat(result.data.result[0].value[1]);
              res.json({
                  status: value === 1 ? 'up' : 'down',
                  responseTime: null
              });
          } else {
              res.json({ status: 'down', responseTime: null });
          }
      });

      // API endpoint to check PostgreSQL
      app.get('/api/check/postgresql', async (req, res) => {
          const result = await queryPrometheus('up{job="postgresql"}');

          if (result && result.status === 'success' && result.data.result.length > 0) {
              const value = parseFloat(result.data.result[0].value[1]);
              res.json({
                  status: value === 1 ? 'up' : 'down',
                  responseTime: null
              });
          } else {
              res.json({ status: 'down', responseTime: null });
          }
      });

      // API endpoint to check Redis
      app.get('/api/check/redis', async (req, res) => {
          const result = await queryPrometheus('up{job="redis"}');

          if (result && result.status === 'success' && result.data.result.length > 0) {
              const value = parseFloat(result.data.result[0].value[1]);
              res.json({
                  status: value === 1 ? 'up' : 'down',
                  responseTime: null
              });
          } else {
              res.json({ status: 'down', responseTime: null });
          }
      });

      // API endpoint to check Kafka
      app.get('/api/check/kafka', async (req, res) => {
          const result = await queryPrometheus('up{job="kafka"}');

          if (result && result.status === 'success' && result.data.result.length > 0) {
              const value = parseFloat(result.data.result[0].value[1]);
              res.json({
                  status: value === 1 ? 'up' : 'down',
                  responseTime: null
              });
          } else {
              res.json({ status: 'down', responseTime: null });
          }
      });

      // API endpoint to check Hetzner (use node exporter if available, or ping)
      app.get('/api/check/hetzner', async (req, res) => {
          // For now, assume up since we're running on it
          res.json({ status: 'up', responseTime: null });
      });

      // API endpoint to get uptime history for a service
      app.get('/api/uptime/:service', async (req, res) => {
          const { service } = req.params;
          const days = parseInt(req.query.days) || 90;

          // Map service names to Prometheus job labels
          const jobMap = {
              'core-pipeline-prod': 'core-pipeline-prod',
              'core-pipeline-dev': 'core-pipeline-dev',
              'postgresql': 'postgresql',
              'redis': 'redis',
              'kafka': 'kafka'
          };

          const job = jobMap[service];
          if (!job) {
              return res.status(404).json({ error: 'Service not found' });
          }

          const end = Math.floor(Date.now() / 1000);
          const start = end - (days * 24 * 60 * 60);

          // Query uptime over the period
          const result = await queryPrometheusRange(
              `avg_over_time(up{job="${job}"}[1h])`,
              start,
              end,
              '1h'
          );

          if (result && result.status === 'success' && result.data.result.length > 0) {
              const values = result.data.result[0].values.map(([timestamp, value]) => ({
                  timestamp: timestamp * 1000,
                  uptime: parseFloat(value) * 100
              }));

              // Group by day
              const dailyUptime = {};
              values.forEach(({ timestamp, uptime }) => {
                  const date = new Date(timestamp).toISOString().split('T')[0];
                  if (!dailyUptime[date]) {
                      dailyUptime[date] = [];
                  }
                  dailyUptime[date].push(uptime);
              });

              const history = Object.entries(dailyUptime).map(([date, uptimes]) => {
                  const avgUptime = uptimes.reduce((sum, val) => sum + val, 0) / uptimes.length;
                  return {
                      date,
                      uptime: avgUptime.toFixed(2),
                      status: avgUptime > 99 ? 'up' : avgUptime > 0 ? 'degraded' : 'down'
                  };
              });

              res.json({ history });
          } else {
              res.json({ history: [] });
          }
      });

      // Health check endpoint
      app.get('/health', (req, res) => {
          res.json({ status: 'ok', service: 'status-page' });
      });

      // Serve index.html for root
      app.get('/', (req, res) => {
          res.sendFile(path.join(__dirname, 'index.html'));
      });

      app.listen(PORT, '0.0.0.0', () => {
          console.log(`Status page server running on port ${PORT}`);
          console.log(`Prometheus URL: ${PROMETHEUS_URL}`);
      });
  kind: ConfigMap
  metadata:
    name: status-page-files
    namespace: status
- apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    annotations:
      argocd.argoproj.io/tracking-id: infrastructure:networking.k8s.io/Ingress:status/gatus
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"networking.k8s.io/v1","kind":"Ingress","metadata":{"annotations":{"argocd.argoproj.io/tracking-id":"infrastructure:networking.k8s.io/Ingress:status/gatus","cert-manager.io/cluster-issuer":"letsencrypt-prod"},"name":"gatus","namespace":"status"},"spec":{"ingressClassName":"nginx","rules":[{"host":"status.theedgestory.org","http":{"paths":[{"backend":{"service":{"name":"gatus","port":{"number":8080}}},"path":"/","pathType":"Prefix"}]}}],"tls":[{"hosts":["status.theedgestory.org"],"secretName":"gatus-tls"}]}}
      nginx.ingress.kubernetes.io/auth-response-headers: X-Auth-Request-User,X-Auth-Request-Email,Authorization
      nginx.ingress.kubernetes.io/auth-signin: https://auth.theedgestory.org/oauth2/start?rd=$scheme://$host$request_uri
      nginx.ingress.kubernetes.io/auth-url: http://oauth2-proxy.oauth2-proxy.svc.cluster.local:4180/oauth2/auth
      nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
      nginx.ingress.kubernetes.io/service-upstream: "true"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    name: gatus
    namespace: status
  spec:
    ingressClassName: nginx
    rules:
    - host: status.theedgestory.org
      http:
        paths:
        - backend:
            service:
              name: gatus
              port:
                number: 80
          path: /
          pathType: Prefix
    tls:
    - hosts:
      - status.theedgestory.org
      secretName: cloudflare-origin-tls
  status:
    loadBalancer:
      ingress:
      - ip: 46.62.223.198
kind: List
metadata:
