#!/bin/bash
set -e

echo "========================================"
echo "INFRASTRUCTURE BOOTSTRAP SETUP"
echo "========================================"

# Color output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

print_success() { echo -e "${GREEN}‚úì $1${NC}"; }
print_warning() { echo -e "${YELLOW}‚ö† $1${NC}"; }
print_error() { echo -e "${RED}‚úó $1${NC}"; }

# Generate secure password
generate_password() {
  openssl rand -base64 32 | tr -d "=+/" | cut -c1-25
}

echo ""
echo "=== Prerequisites Check ==="
command -v kubectl >/dev/null 2>&1 || { print_error "kubectl not found"; exit 1; }
command -v helm >/dev/null 2>&1 || { print_error "helm not found"; exit 1; }
command -v openssl >/dev/null 2>&1 || { print_error "openssl not found"; exit 1; }
print_success "All prerequisites satisfied"

echo ""
echo "=== Generate Admin Secrets ==="
POSTGRES_ADMIN_PASSWORD=$(generate_password)
REDIS_ADMIN_PASSWORD=$(generate_password)

print_success "Generated admin passwords"

echo ""
echo "=== Create Namespaces ==="
kubectl create namespace database --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace redis --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace kafka --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace dev-core --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace prod-core --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace infrastructure --dry-run=client -o yaml | kubectl apply -f -
print_success "Namespaces created"

echo ""
echo "=== Create Infrastructure Admin Secrets ==="

# PostgreSQL admin secret
kubectl create secret generic postgresql \
  --from-literal=postgres-password=$POSTGRES_ADMIN_PASSWORD \
  --from-literal=password=$POSTGRES_ADMIN_PASSWORD \
  --namespace=database \
  --dry-run=client -o yaml | kubectl apply -f -

# Redis admin secret
kubectl create secret generic redis \
  --from-literal=redis-password=$REDIS_ADMIN_PASSWORD \
  --namespace=redis \
  --dry-run=client -o yaml | kubectl apply -f -

print_success "Infrastructure admin secrets created"
print_warning "Note: Application-specific secrets (PostgreSQL users, Redis ACLs) will be auto-generated by Helm"

echo ""
echo "=== Install cert-manager ==="
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager
kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager
print_success "cert-manager installed"

echo ""
echo "=== Apply cert-manager host network fix ==="
kubectl patch deployment cert-manager -n cert-manager --type=merge -p '{"spec":{"template":{"spec":{"hostNetwork":true}}}}'
kubectl rollout status deployment/cert-manager -n cert-manager --timeout=120s
print_success "cert-manager configured"

echo ""
echo "=== Install ArgoCD ==="
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
print_success "ArgoCD installed"

echo ""
echo "=== Deploy Infrastructure Helm Charts ==="
# Add helm repos if needed
helm repo add bitnami https://charts.bitnami.com/bitnami || true
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true
helm repo add grafana https://grafana.github.io/helm-charts || true
helm repo update

# Deploy infrastructure
helm upgrade --install infrastructure ./charts/infrastructure \
  --namespace default \
  --create-namespace \
  --wait \
  --timeout 10m

print_success "Infrastructure deployed"
print_warning "Note: PostgreSQL and Redis users are auto-created with unique passwords per service"

echo ""
echo "=== Apply ArgoCD Applications ==="
kubectl apply -f argocd-apps/ -n argocd || true
print_success "ArgoCD applications configured"

echo ""
echo "========================================"
echo "SETUP COMPLETE!"
echo "========================================"

echo ""
echo "üìù Admin Credentials (save securely):"
echo ""
echo "PostgreSQL Admin:"
echo "  User: postgres"
echo "  Password: $POSTGRES_ADMIN_PASSWORD"
echo ""
echo "Redis Admin:"
echo "  Password: $REDIS_ADMIN_PASSWORD"
echo ""
echo "ArgoCD Admin:"
echo "  User: admin"
echo "  Get password: kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d"
echo ""
echo "Grafana Admin:"
echo "  User: admin"  
echo "  Get password: kubectl -n monitoring get secret grafana -o jsonpath='{.data.admin-password}' | base64 -d"
echo ""
echo "üìä Application Database Credentials:"
echo "  Dev: kubectl -n database get secret postgres-core-pipeline-dev-secret -o yaml"
echo "  Prod: kubectl -n database get secret postgres-core-pipeline-prod-secret -o yaml"
echo ""
echo "üîê Application Redis Credentials:"
echo "  Dev: kubectl -n redis get secret redis-dev-secret -o yaml"
echo "  Prod: kubectl -n redis get secret redis-prod-secret -o yaml"
echo ""
echo "========================================"
echo "Security Isolation Summary:"
echo "  ‚úì PostgreSQL: Unique user per database (core_dev_user, core_prod_user)"
echo "  ‚úì Redis: ACL-based isolation (redis_dev_user, redis_prod_user)"
echo "  ‚úì Secrets: Auto-replicated to application namespaces with proper isolation"
echo "========================================"
echo ""
echo "Next steps:"
echo "  1. Run: ./health-check.sh"
echo "  2. Run: ./scripts/comprehensive-health-check.sh"
echo "  3. Access ArgoCD: https://argo.dev.theedgestory.org"
echo "  4. Access Grafana: https://grafana.dev.theedgestory.org"
echo "========================================"
